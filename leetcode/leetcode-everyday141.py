# 一个下标从 0 开始的数组的 交替和 定义为 偶数 下标处元素之 和 减去 奇数 下标处元素之 和 。
# 比方说，数组 [4,2,5,3] 的交替和为 (4 + 5) - (2 + 3) = 4 。
# 给你一个数组 nums ，请你返回 nums 中任意子序列的 最大交替和 （子序列的下标 重新 从 0 开始编号）。
# 一个数组的 子序列 是从原数组中删除一些元素后（也可能一个也不删除）剩余元素不改变顺序组成的数组。比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的一个子序列（加粗元素），但是 [2,4,2] 不是。

# 能大概想到动态规划思路，但其中奇偶思路比较难理清
class Solution:
    def maxAlternatingSum(self, nums: list[int]) -> int:
        # 最大交替和一定是奇数个元素
        # 动态规划：基于前i-1个数，当前第i个数是否选择
        # 状态转移方程：区分子序列中奇数偶数下标
        f=[0]*(len(nums)+1) # 最后一个元素为偶数下标
        g=[0]*(len(nums)+1) # 最后一个元素为奇数下标
        # 前i个数
        for i in range(1,len(nums)+1):
            f[i] = max(g[i - 1]+nums[i-1], f[i - 1])
            g[i] = max(f[i - 1]-nums[i-1], g[i - 1])
        return f[len(nums)]
